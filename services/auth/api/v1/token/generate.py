import webexteamssdk

from app import app
from setup_api import v1

from encoder import JWTEncoder
from flask import request
from flask_restx import Resource
from werkzeug.exceptions import BadRequest


@v1.route('/token/generate')
class TokenGenerateApi(Resource):
    expiration = 10  # minutes

    def post(self) -> dict[str, dict[str, bool]]:
        if 'email' not in request.json:
            raise BadRequest("'email' key is required.")

        bot = webexteamssdk.WebexTeamsAPI(app.config['WEBEX_TEAMS_ACCESS_TOKEN'])

        # Generate the message so that we can use the ID to encode in the JWT token
        try:
            message = bot.messages.create(
                toPersonEmail=request.json['email'],
                markdown='Generating JWT...'
            )
        except webexteamssdk.exceptions.ApiError as e:
            if e.status_code == 400:
                raise BadRequest(f'A Webex Account with email "{request.json["email"]}" does not exist.')

        # Edit message so that the message ID can be encoded in the JWT
        # This is so that the message in teams can be deleted when it's consumed.
        # That way, althought the token expires in 10 minutes, the deletion of the message helps to regulate it's only
        # consumed once. Though this is not an assumption we can depend on in any strict sense.

        # SDK does not have "edit message" feature, just hit endpoint directly.
        token = JWTEncoder(expiration={'minutes': self.expiration}).encode(**{
            'email': request.json['email'],
            'messageId': message.id
        })

        bot._session.put(f'/messages/{message.id}', json={
            'markdown': f'Your temporary token is shown below. This token will expire in {self.expiration} minutes:' +
                        # TODO: should delete message and invalidate (blacklist) token
                        f'\n\n{token}\n\nWas this not generated by you? ' +
                        f'[Click Here]({app.config["FQDN"]}/api/v1/auth/token/invalidate?token={token})',
            'roomId': message.roomId
        })

        return {'data': {'success': True}}
